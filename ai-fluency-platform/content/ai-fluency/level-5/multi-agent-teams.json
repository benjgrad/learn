{
  "meta": {
    "title": "5.8 Multi-Agent Teams",
    "description": "Coordinating multiple agents on shared objectives with task lists, message passing, and graceful lifecycle management.",
    "level": "level-5",
    "slug": "multi-agent-teams",
    "order": 0,
    "isCheckpoint": false,
    "isIndex": false
  },
  "blocks": [
    {
      "type": "markdown",
      "content": "# 5.8 Multi-Agent Teams"
    },
    {
      "type": "predictPrompt",
      "prompt": "Module 5.7 covered subagents -- a parent spawning short-lived helpers for specific tasks. But what if you need multiple agents working together as peers over a longer period, collaborating on a shared objective? What coordination mechanisms would they need that subagents do not have?"
    },
    {
      "type": "markdown",
      "content": "## Teams vs. Subagents\n\nSubagents and teams solve different coordination problems:\n\n| Dimension | Subagents | Teams |\n|-----------|-----------|-------|\n| Relationship | Parent-child (hierarchical) | Peer collaboration (flat or led) |\n| Lifecycle | Short-lived, single task | Long-lived, multiple tasks |\n| Communication | Parent sends brief, child returns result | Bidirectional messaging between all members |\n| Shared state | None -- isolated by design | Shared task list, message history |\n| Coordination | Parent orchestrates everything | Self-organizing with optional team lead |\n\nUse subagents when you need focused, isolated, one-shot work. Use teams when the work requires ongoing collaboration, shared context, and dynamic task allocation.\n\n### When Teams Shine\n\n- **Large migrations**: Converting a codebase from JavaScript to TypeScript requires agents to coordinate on shared types, avoid conflicts, and maintain consistency\n- **Full-stack features**: One agent works on the API, another on the frontend, a third on tests -- they need to agree on interfaces\n- **Complex audits**: Security, performance, and accessibility reviews that need cross-cutting analysis\n- **Documentation projects**: Multiple agents writing different sections that must be consistent and cross-referenced"
    },
    {
      "type": "markdown",
      "content": "## Team Architecture\n\nA multi-agent team consists of:\n\n1. **A team lead**: Coordinates work, creates tasks, monitors progress\n2. **Teammates**: Specialized agents that claim and execute tasks\n3. **A shared task list**: The single source of truth for what needs to be done\n4. **A messaging system**: For communication between agents\n\n```\n┌─────────────────────────────────────────────────┐\n│                  Team Lead                       │\n│  - Creates and assigns tasks                     │\n│  - Monitors progress                             │\n│  - Resolves conflicts                            │\n│  - Communicates with the human user              │\n├─────────────────────────────────────────────────┤\n│              Shared Task List                    │\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐            │\n│  │ Task 1  │ │ Task 2  │ │ Task 3  │ ...        │\n│  │ pending │ │ in_prog │ │ done    │            │\n│  └─────────┘ └─────────┘ └─────────┘            │\n├──────────┬──────────┬───────────────────────────┤\n│ Agent A  │ Agent B  │ Agent C                    │\n│ (types)  │ (API)    │ (tests)                    │\n└──────────┴──────────┴───────────────────────────┘\n```"
    },
    {
      "type": "calibrationCheck",
      "question": "Why is a shared task list critical for multi-agent teams? What goes wrong if agents coordinate only through messages?",
      "answer": "A shared task list provides several things that messages alone cannot: (1) **Single source of truth** -- every agent can see what has been done, what is in progress, and what remains, without relying on their memory of past messages. (2) **Dependency tracking** -- tasks can declare 'blockedBy' relationships, preventing agents from starting work that depends on unfinished prerequisites. (3) **Conflict prevention** -- if Agent A claims Task 2, Agent B can see this and work on something else, avoiding duplicate effort. (4) **Progress visibility** -- the team lead (and the human user) can see overall progress at a glance. With messages alone, agents might duplicate work, miss dependencies, lose track of what has been completed, or fail to communicate status -- the same coordination failures that plague human teams without project management tools."
    },
    {
      "type": "markdown",
      "content": "## Task Management\n\n### Task Structure\n\nEach task in the shared list has:\n- **Subject**: A brief, actionable title (e.g., \"Convert src/auth/ to TypeScript\")\n- **Description**: Detailed requirements, context, and acceptance criteria\n- **Status**: `pending` -> `in_progress` -> `completed`\n- **Owner**: Which agent has claimed the task\n- **Dependencies**: `blocks` (tasks waiting on this one) and `blockedBy` (prerequisites)\n\n### Status Flow\n\n```\npending ──> in_progress ──> completed\n   │                           │\n   └── (claimed by an agent)   └── (work verified)\n```\n\nThe discipline around status transitions matters:\n- An agent should mark a task `in_progress` **before** starting work (prevents two agents from claiming the same task)\n- A task should only be marked `completed` when the work is **fully done** -- not partially done, not \"mostly works\"\n- If an agent gets blocked, it should keep the task as `in_progress` and communicate the blocker\n\n### Dependencies\n\nDependencies prevent agents from starting work that would fail or conflict:\n\n```\nTask 1: \"Define shared TypeScript interfaces\"    [no dependencies]\nTask 2: \"Convert auth module to TypeScript\"       [blockedBy: Task 1]\nTask 3: \"Convert API routes to TypeScript\"        [blockedBy: Task 1]\nTask 4: \"Update integration tests\"                [blockedBy: Task 2, Task 3]\n```\n\nTasks 2 and 3 cannot start until Task 1 completes (they need the shared interfaces). Task 4 cannot start until both conversions are done. Tasks 2 and 3 *can* run in parallel since they are independent of each other."
    },
    {
      "type": "markdown",
      "content": "## Communication: DMs vs. Broadcasts\n\nMulti-agent teams communicate through two channels:\n\n### Direct Messages (DMs)\n\nA message from one agent to a specific other agent. Use for:\n- Following up on a specific task\n- Asking a question that only one teammate can answer\n- Sharing findings relevant to one agent's work\n- Most routine coordination\n\n### Broadcasts\n\nA message sent to **all** teammates simultaneously. Use sparingly because:\n- Each broadcast sends N separate messages (one per teammate)\n- Each delivery consumes API resources (tokens, compute)\n- Cost scales linearly with team size\n- Too many broadcasts create noise, and agents start ignoring them\n\n**Valid broadcast use cases:**\n- Critical blockers that affect everyone (\"The database is down, pause all DB-related work\")\n- Architectural decisions that change everyone's approach (\"We are using Zod for all validation, not io-ts\")\n- Completion of a milestone that unblocks multiple agents\n\n**Use DMs instead for:**\n- Normal status updates\n- Questions for a specific teammate\n- Sharing findings relevant to only some agents\n\nThe rule of thumb: if you are unsure whether to DM or broadcast, DM. You can always follow up with others individually."
    },
    {
      "type": "calibrationCheck",
      "question": "A team has 8 agents. The team lead broadcasts a status request: 'Everyone report your current progress.' What is the cost of this communication pattern, and what is a better approach?",
      "answer": "The broadcast sends 8 messages (one to each agent). Each agent then responds, generating 8 more messages back to the team lead. That is 16 messages for a simple status check. If agents respond with broadcasts instead of DMs, it becomes 8 * 8 = 64 messages. This is expensive and wasteful. A better approach: the team lead should check the shared task list, which already shows each task's status and owner. If specific details are needed, the team lead sends DMs to individual agents whose tasks need clarification. The task list is the primary coordination mechanism; messages supplement it, not replace it."
    },
    {
      "type": "markdown",
      "content": "## Team Lifecycle\n\nA multi-agent team goes through five phases:\n\n### 1. Creation\nThe team lead (or a human) creates the team, defining:\n- Team name and objective\n- Teammate names and specializations\n- Initial configuration (model, tools, system prompts)\n\n### 2. Planning\nThe team lead analyzes the objective and creates the initial task list:\n- Break the objective into discrete, parallelizable tasks\n- Define dependencies between tasks\n- Estimate which tasks can run concurrently\n\n### 3. Execution\nTeammates claim tasks, work on them, and communicate:\n- Each agent checks the task list for available work\n- Agents prefer tasks in ID order (earlier tasks often set up context)\n- Work proceeds in parallel where dependencies allow\n- Agents communicate through DMs when they need input from each other\n\n### 4. Monitoring\nThe team lead tracks progress and resolves issues:\n- Are any agents stuck or idle?\n- Are there tasks that no one has claimed?\n- Do dependencies need to be updated based on new information?\n- Are agents producing consistent, compatible work?\n\n### 5. Shutdown\nWhen all tasks are complete, the team shuts down gracefully.\n\n## Shutdown Protocols\n\nGraceful shutdown is surprisingly important and often overlooked. Problems with ungraceful shutdown:\n\n- **Lost work**: An agent mid-task that is killed loses its in-progress results\n- **Dangling resources**: Agents may have open file handles, database connections, or running processes\n- **Inconsistent state**: If one agent shuts down while another depends on its output, the dependent agent fails\n\n### The Shutdown Sequence\n\n1. **Team lead initiates**: Sends shutdown requests to each teammate\n2. **Agents acknowledge**: Each agent finishes its current tool call, saves state, and confirms readiness to shut down\n3. **Grace period**: Agents have time to complete in-progress operations\n4. **Agent rejects shutdown** (optional): An agent that is mid-task can reject the shutdown request with a reason (\"Still working on Task 7, need 2 more minutes\")\n5. **Confirmation**: Once all agents approve, the team shuts down\n\n```typescript\n// Shutdown protocol flow\ninterface ShutdownRequest {\n  type: \"shutdown_request\";\n  requestId: string;\n  reason: string;\n}\n\ninterface ShutdownResponse {\n  type: \"shutdown_response\";\n  requestId: string;\n  approve: boolean;\n  reason?: string; // if rejecting\n}\n\n// Team lead sends to each agent:\n// { type: \"shutdown_request\", requestId: \"abc\", reason: \"All tasks complete\" }\n\n// Agent responds:\n// { type: \"shutdown_response\", requestId: \"abc\", approve: true }\n// OR\n// { type: \"shutdown_response\", requestId: \"abc\", approve: false,\n//   reason: \"Writing final test results to disk\" }\n```\n\nThis protocol prevents the data-loss scenario where an agent is killed mid-operation. It mirrors graceful shutdown patterns in distributed systems (SIGTERM handling, drain connections, then exit)."
    },
    {
      "type": "tryItYourself",
      "title": "Design a multi-agent team for migrating a 50-file JavaScript project to TypeScript. Define: the team members (name, specialization, tools), the task list (at least 8 tasks with dependencies), and the shutdown sequence. Consider what happens if the types agent finishes before the migration agents.",
      "solution": "**Team: js-to-ts-migration**\n\n**Team Members:**\n1. `team-lead` -- Coordinates work, creates tasks, resolves conflicts. Tools: all.\n2. `type-designer` -- Defines shared TypeScript interfaces and types. Tools: read, write, search.\n3. `migrator-a` -- Converts source files to TypeScript. Tools: read, write, execute (for type checking).\n4. `migrator-b` -- Converts source files to TypeScript (parallel with migrator-a). Tools: read, write, execute.\n5. `test-updater` -- Updates test files for TypeScript compatibility. Tools: read, write, execute.\n\n**Task List:**\n\n| ID | Task | Owner | Blocked By |\n|----|------|-------|------------|\n| 1 | Configure tsconfig.json and install TypeScript dependencies | team-lead | -- |\n| 2 | Define shared interfaces for src/models/ | type-designer | 1 |\n| 3 | Define shared interfaces for src/api/ request/response types | type-designer | 1 |\n| 4 | Convert src/models/ to TypeScript | migrator-a | 2 |\n| 5 | Convert src/utils/ to TypeScript | migrator-b | 1 |\n| 6 | Convert src/api/routes/ to TypeScript | migrator-a | 3, 4 |\n| 7 | Convert src/services/ to TypeScript | migrator-b | 4, 5 |\n| 8 | Update all test files for TypeScript | test-updater | 4, 5, 6, 7 |\n| 9 | Run full test suite and fix type errors | team-lead | 8 |\n| 10 | Remove old .js files and update build config | team-lead | 9 |\n\n**Execution Flow:**\n- Task 1 runs first (team-lead)\n- Tasks 2, 3, 5 can run in parallel after Task 1\n- Tasks 4, 6, 7 have staggered dependencies\n- Task 8 waits for all migrations, then tests update\n- Tasks 9, 10 are sequential cleanup\n\n**Shutdown Sequence:**\n1. type-designer finishes Tasks 2 and 3 early. Team lead checks task list -- no more type-design tasks. Sends shutdown_request to type-designer.\n2. type-designer approves shutdown, exits.\n3. migrator-a and migrator-b continue working on Tasks 4-7.\n4. When Tasks 4-7 complete, migrator-a and migrator-b have no more work. Team lead sends shutdown_requests.\n5. Both approve and exit.\n6. test-updater works on Task 8. When complete, team lead sends shutdown_request. test-updater approves.\n7. Team lead handles Tasks 9-10 alone, then reports completion to the user."
    },
    {
      "type": "explainBack",
      "prompt": "Explain to a colleague how a multi-agent team coordinates work. Cover the shared task list, dependency management, the difference between DMs and broadcasts, and why graceful shutdown matters. Use a concrete example."
    },
    {
      "type": "keyTakeaway",
      "content": "Multi-agent teams enable peer collaboration on shared objectives, going beyond the parent-child model of subagents. They coordinate through shared task lists (with status flow and dependency tracking), direct messages (for targeted communication), and broadcasts (sparingly, for team-wide critical updates). The team lifecycle spans creation, planning, execution, monitoring, and graceful shutdown. Shutdown protocols prevent lost work and inconsistent state by letting agents finish in-progress operations before exiting."
    },
    {
      "type": "connectPrompt",
      "prompt": "How do multi-agent team patterns mirror distributed systems concepts like leader election, consensus, and graceful degradation? What happens when the team lead agent fails mid-coordination?"
    },
    {
      "type": "reflectPrompt",
      "questions": [
        "What tasks in your daily work would benefit from a team of AI agents working in parallel? Where would the coordination overhead not be worth it?",
        "How does the DM vs. broadcast decision mirror communication patterns in human teams? When have you seen broadcast-style communication (e.g., @channel in Slack) become counterproductive?",
        "What safeguards would you want before trusting a multi-agent team to work on production code without human oversight at every step?"
      ]
    },
    {
      "type": "providerContent",
      "context": "Multi-agent team capabilities are an emerging feature across AI coding tools. Here is the current state of team support in each provider.",
      "providers": {
        "claude-code": "## Claude Code: Native Team Support\n\nClaude Code has built-in support for multi-agent teams, making it one of the first coding assistants with native team coordination.\n\n### Creating a Team\n\nTeams are created through the `TeamCreate` capability, specifying teammates with names, models, and system prompts:\n\n```\nTeam: \"migration-team\"\nTeammates:\n  - name: \"type-designer\"\n    model: claude-sonnet-4-5-20250929\n    prompt: \"You specialize in TypeScript type design...\"\n  - name: \"migrator\"\n    model: claude-sonnet-4-5-20250929\n    prompt: \"You convert JavaScript files to TypeScript...\"\n```\n\n### Task Management\n\nClaude Code provides `TaskCreate`, `TaskUpdate`, `TaskList`, and `TaskGet` tools for managing the shared task list. Tasks support:\n- Status: `pending`, `in_progress`, `completed`\n- Owner assignment\n- `blocks` and `blockedBy` dependencies\n- Metadata for arbitrary key-value data\n\n### Message Passing\n\nThe `SendMessage` tool supports:\n- **type: \"message\"** -- DM to a specific teammate by name\n- **type: \"broadcast\"** -- Message all teammates (use sparingly)\n- **type: \"shutdown_request\"** -- Ask a teammate to gracefully shut down\n- **type: \"shutdown_response\"** -- Approve or reject a shutdown request\n\n### Idle State Management\n\nWhen a teammate finishes its current task and no new tasks are available, it enters an idle state. The system automatically notifies the team lead, who can assign new work or initiate shutdown.\n\n### Team Config Files\n\nTeam configurations can be defined in project-level config files, making team structures repeatable and version-controlled.",
        "codex": "## Codex: Multi-Agent Patterns\n\nOpenAI's Codex does not have built-in multi-agent team support equivalent to Claude Code's TeamCreate. However, multi-agent patterns can be implemented through the OpenAI platform.\n\n### Agents SDK\n\nThe OpenAI Agents SDK provides primitives for multi-agent coordination:\n\n```python\nfrom openai import agents\n\n# Define specialized agents\nresearcher = agents.Agent(\n    name=\"researcher\",\n    model=\"o3\",\n    tools=[web_search, file_read],\n    instructions=\"Research and gather information.\"\n)\n\ncoder = agents.Agent(\n    name=\"coder\",\n    model=\"codex-mini\",\n    tools=[file_write, terminal],\n    instructions=\"Implement code changes.\"\n)\n\n# Handoff between agents\nresearcher.handoffs = [coder]  # researcher can delegate to coder\n```\n\n### Parallel Execution\n\nMultiple Codex CLI instances can run in parallel on different tasks. Each instance operates in its own sandbox, preventing conflicts. Results can be merged through Git branches.\n\n### Coordination Challenges\n\nWithout a built-in shared task list, coordination between Codex instances requires external tooling (e.g., a shared file, a database, or a project management API). This is an area where the ecosystem is evolving.",
        "cline": "## Cline: Multi-Agent Extensions and Community Patterns\n\nCline does not have native multi-agent team support, but the community has developed patterns for coordinating multiple Cline instances.\n\n### Multiple VS Code Windows\n\nThe simplest multi-agent pattern with Cline is running multiple VS Code windows, each with its own Cline instance working on different parts of the codebase. Coordination happens through:\n- Git branches (each instance works on its own branch)\n- Shared documentation files that serve as a task list\n- The human developer acting as the team lead\n\n### Community Extensions\n\nSome community extensions add coordination features:\n- Shared context files that multiple Cline instances can read\n- Task tracking through markdown files in the project\n- Profile switching to give different instances different capabilities\n\n### Practical Approach\n\nFor most Cline users, the practical approach to multi-agent work is:\n1. Break the project into independent modules\n2. Open each module in a separate VS Code window with Cline\n3. Define interfaces and shared types first (manually or with one instance)\n4. Let each instance work independently on its module\n5. Integrate and resolve conflicts manually through Git",
        "gemini": "## Gemini: ADK Multi-Agent Capabilities\n\nGoogle's Agent Development Kit (ADK) provides structured support for multi-agent systems.\n\n### ADK Team Patterns\n\nADK supports several multi-agent architectures:\n\n```python\nfrom google.adk import Agent, Team\n\n# Define specialized agents\nplanner = Agent(\n    name=\"planner\",\n    model=\"gemini-2.5-pro\",\n    instruction=\"Break tasks into subtasks and coordinate.\"\n)\n\nimplementer = Agent(\n    name=\"implementer\",\n    model=\"gemini-2.5-flash\",\n    instruction=\"Write code based on specifications.\"\n)\n\nreviewer = Agent(\n    name=\"reviewer\",\n    model=\"gemini-2.5-pro\",\n    instruction=\"Review code for correctness and style.\"\n)\n\n# Create a team with a coordinator\nteam = Team(\n    agents=[planner, implementer, reviewer],\n    coordinator=planner\n)\n```\n\n### Jules Multi-Step Coordination\n\nJules handles multi-agent-like coordination internally by breaking complex coding tasks into plans with discrete steps. While not a true multi-agent system (it is a single agent with planning), it achieves similar outcomes for code migration and refactoring tasks.\n\n### Vertex AI Agent Builder\n\nFor production deployments, Vertex AI Agent Builder provides a managed platform for deploying multi-agent systems with built-in monitoring, logging, and scaling. Agents communicate through Pub/Sub topics or Cloud Tasks, providing durable message passing."
      }
    }
  ]
}
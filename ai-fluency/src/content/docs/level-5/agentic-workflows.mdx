---
title: "5.5 Agentic Workflows"
description: "ReAct prompting, tool use, multi-agent systems, and orchestration patterns for autonomous AI."
---

import PredictPrompt from '../../../components/learning/PredictPrompt.astro';
import TryItYourself from '../../../components/learning/TryItYourself.astro';
import CalibrationCheck from '../../../components/learning/CalibrationCheck.astro';
import ExplainBack from '../../../components/learning/ExplainBack.astro';
import ReflectPrompt from '../../../components/learning/ReflectPrompt.astro';
import ConnectPrompt from '../../../components/learning/ConnectPrompt.astro';
import KeyTakeaway from '../../../components/learning/KeyTakeaway.astro';

# 5.5 Agentic Workflows

<PredictPrompt prompt="Standard AI interactions are one-shot: user asks, model responds. What would change if the model could use tools, take actions, and run multi-step plans autonomously? What new risks and opportunities emerge?" />

## From Chat to Agency

The three modes of AI engagement define a progression:

1. **Automation**: AI performs a single defined task (summarize this, classify that)
2. **Augmentation**: Human and AI think together (co-writing, code review)
3. **Agency**: AI works independently, making decisions and taking actions on behalf of the human

Agentic workflows live in the third mode. An AI agent is a system where the model:
- **Observes** the current state
- **Reasons** about what to do next
- **Acts** by calling tools or producing outputs
- **Reflects** on the results to decide the next step

This loop continues until the task is complete or the agent decides it needs human input.

## ReAct: Reasoning + Acting

The ReAct framework (Reasoning and Acting) interleaves thinking with tool use. Instead of generating a complete answer from memory, the model reasons about what it needs, uses a tool to get real information, then continues reasoning.

```
User: What was Apple's stock price change on its last earnings day?

Thought: I need to find Apple's most recent earnings date, then look up
         the stock price change on that day.
Action: search("Apple AAPL most recent earnings date 2026")
Observation: Apple reported Q1 2026 earnings on January 30, 2026.

Thought: Now I need the stock price change on January 30, 2026.
Action: lookup_stock_price("AAPL", "2026-01-30")
Observation: Open: $242.50, Close: $251.80, Change: +3.83%

Thought: I have both pieces of information. I can now answer.
Answer: Apple's stock rose 3.83% on its most recent earnings day
        (January 30, 2026), closing at $251.80.
```

The key advantage of ReAct over pure generation is **grounding** -- the model's claims are based on real tool outputs, not memory that might be stale or incorrect.

### Implementing a ReAct Loop

```typescript
interface Tool {
  name: string;
  description: string;
  parameters: Record<string, unknown>;
  execute: (params: Record<string, unknown>) => Promise<string>;
}

async function reactLoop(
  query: string,
  tools: Tool[],
  maxSteps: number = 10
): Promise<string> {
  const messages = [
    { role: "system", content: buildSystemPrompt(tools) },
    { role: "user", content: query },
  ];

  for (let step = 0; step < maxSteps; step++) {
    const response = await callModel(messages, { tools });

    if (response.type === "text") {
      return response.content; // Agent decided to answer
    }

    if (response.type === "tool_call") {
      const tool = tools.find(t => t.name === response.toolName);
      const result = await tool.execute(response.parameters);

      messages.push(
        { role: "assistant", content: response.raw },
        { role: "tool", content: result },
      );
    }
  }

  return "Agent reached maximum steps without a final answer.";
}
```

<CalibrationCheck question="What is the main risk of a ReAct agent compared to a simple prompt-and-respond system? Why does adding tool use increase the potential for failure?">
Each step in a ReAct loop introduces a new point of failure. The model might: call the wrong tool, pass incorrect parameters, misinterpret tool output, enter an infinite loop, or take an irreversible action. With N steps, the probability of at least one error is 1 - (1-p)^N, where p is the per-step error rate. Even a 5% per-step error rate means a 40% chance of failure in a 10-step plan. This is why agentic workflows need robust error handling, step limits, and human oversight for consequential actions.
</CalibrationCheck>

## Tool Use

Modern AI APIs provide native support for tool use (also called "function calling"):

```typescript
// Define tools the model can use
const tools = [
  {
    name: "get_weather",
    description: "Get current weather for a location",
    parameters: {
      type: "object",
      properties: {
        location: { type: "string", description: "City name" },
        unit: { type: "string", enum: ["celsius", "fahrenheit"] },
      },
      required: ["location"],
    },
  },
  {
    name: "search_web",
    description: "Search the web for current information",
    parameters: {
      type: "object",
      properties: {
        query: { type: "string" },
      },
      required: ["query"],
    },
  },
];

// Model decides when and how to use tools
const response = await anthropic.messages.create({
  model: "claude-sonnet-4-5-20250929",
  messages: [{ role: "user", content: "What's the weather in Tokyo?" }],
  tools: tools,
});
// Response includes a tool_use block with name="get_weather" and input={location: "Tokyo"}
```

The model does not execute the tools -- it produces a structured request specifying which tool to call and with what parameters. Your code executes the tool and feeds the result back.

## Multi-Agent Systems

For complex tasks, multiple specialized agents can collaborate:

### Orchestration Patterns

**Sequential Pipeline**: Each agent handles one stage, passing results to the next.
```
Research Agent ──> Writing Agent ──> Review Agent ──> Final Output
```

**Supervisor Pattern**: A central agent delegates tasks and synthesizes results.
```
              ┌── Research Agent
Supervisor ───┼── Analysis Agent
              └── Writing Agent
```

**Debate / Adversarial**: Agents argue different positions, improving through disagreement.
```
Proposer Agent ──> Critic Agent ──> Proposer refines ──> ... ──> Consensus
```

<TryItYourself title="Design a multi-agent system for automated code review. Define at least three specialized agents, their tools, and how they coordinate. Consider: What does each agent focus on? How do they share findings? Who makes the final decision?">
**Agent 1: Security Reviewer**
- Focus: Vulnerabilities, injection risks, authentication issues
- Tools: `run_sast_scanner`, `check_dependency_vulnerabilities`, `search_cve_database`
- Output: List of security findings with severity ratings

**Agent 2: Style & Standards Reviewer**
- Focus: Code style, naming conventions, architectural patterns
- Tools: `run_linter`, `check_test_coverage`, `compare_to_style_guide`
- Output: Style violations and improvement suggestions

**Agent 3: Logic Reviewer**
- Focus: Correctness, edge cases, performance
- Tools: `run_tests`, `analyze_complexity`, `check_error_handling`
- Output: Logic issues and potential bugs

**Supervisor Agent**:
- Receives findings from all three agents
- Deduplicates and prioritizes issues
- Produces a unified review with the most critical items first
- Has the tool `post_review_comment` to write the final GitHub review

Coordination: Supervisor dispatches the code diff to all three agents in parallel, collects their reports, then synthesizes a final review. If any agent reports a critical security issue, the supervisor automatically requests changes rather than approving.
</TryItYourself>

## Guardrails and Safety

Agentic systems require additional safety measures:

1. **Action boundaries**: Define what the agent is and is not allowed to do. Separate read-only tools from write tools.
2. **Human-in-the-loop**: Require human approval for irreversible or high-impact actions (sending emails, making purchases, deleting data).
3. **Step limits**: Cap the maximum number of reasoning steps to prevent runaway loops.
4. **Cost limits**: Set per-task token budgets to prevent expensive reasoning spirals.
5. **Output filtering**: Validate agent outputs before they reach external systems.

```typescript
interface AgentPolicy {
  maxSteps: number;
  maxTokenBudget: number;
  allowedTools: string[];
  requireApproval: string[];  // tools needing human sign-off
  forbiddenActions: string[];
}
```

<ExplainBack prompt="Explain the ReAct framework and why it is more reliable than asking a model to answer complex questions from memory alone. Include the reasoning-acting-observing loop in your explanation." />

<KeyTakeaway>
Agentic workflows give AI the ability to reason, use tools, and take multi-step actions autonomously. The ReAct framework interleaves thinking and tool use for grounded responses. Multi-agent systems let specialized agents collaborate on complex tasks. But agency comes with compounding error risk, making guardrails, step limits, and human oversight essential for production safety.
</KeyTakeaway>

<ConnectPrompt prompt="How do the engineering patterns from Level 4 (circuit breakers, retries, fallback chains) apply to agentic workflows? What happens when a tool call fails in the middle of a multi-step plan?" />

<ReflectPrompt questions={[
  "Where is the line between 'useful automation' and 'risky autonomy' in your work context?",
  "How would you test an agentic workflow where the model's decisions change based on tool outputs?",
  "What governance and oversight structures should organizations put in place before deploying agentic AI?"
]} />
